# Genesis/javac Parity Test Plan

This document outlines the test plan for ensuring functional parity between class files generated by Genesis and those generated by javac.

## Current Status

| Metric | Genesis | javac | Notes |
|--------|---------|-------|-------|
| Errors | 0 | 0 | Both compile cleanly |
| Class files | 942 | 971 | 29 difference (switch map classes) |
| Signature mismatches | 0 | 0 | All functionally equivalent |
| Known differences | Switch map classes, static init | - | Acceptable differences |

## Known Acceptable Differences

### 1. Switch Map Classes
javac generates synthetic inner classes (`$1`, `$2`, etc.) containing `$SwitchMap$...` arrays for enum switch statements. Genesis implements enum switches by calling `ordinal()` directly, which is functionally equivalent but produces different bytecode.

**Impact**: None - both approaches produce identical runtime behavior.

---

## Known Issues to Fix

### 1. Interface Methods via Abstract Superclass (Acceptable)
javac generates bridge methods when a concrete class extends an abstract class that implements an interface.

**Example (Context.java)** - extends `DeploymentDescriptor implements Description`:
```java
// Methods like getDescription(), getDisplayName() are in DeploymentDescriptor
// javac generates bridge methods in Context with ACC_BRIDGE, ACC_SYNTHETIC
// Genesis doesn't generate these bridges
```

**Impact**: None - the JVM resolves these through the superclass chain at runtime.

**Status**: ACCEPTABLE (not required for correctness)

### 2. Static Initializer Differences (Acceptable)
Genesis generates `<clinit>` methods to initialize `static final` fields even when they have compile-time constant expressions (like `8192`). javac uses ConstantValue attributes instead and omits the `<clinit>` when not needed.

**Example (JSONParser)**:
```java
private static final int DEFAULT_BUFFER_SIZE = 8192;
private static final int MAX_CHAR_BUFFER = 8192;
```

```
Genesis: methods: 10 (includes static {})
         static { DEFAULT_BUFFER_SIZE = 8192; MAX_CHAR_BUFFER = 8192; }
         
javac:   methods: 9 (no static {})
         fields have ConstantValue attribute with value 8192
```

**Impact**: Functionally equivalent. Both yield the same field values at runtime.
- Minor size difference (extra method in class file)
- Minor initialization overhead (JVM runs `<clinit>` vs reading ConstantValue)

**Status**: ACCEPTABLE (optimization possible but not required for correctness)

### 2. Constant Pool Organization
The constant pool may contain entries in different orders, and Genesis may merge or deduplicate entries differently than javac.

**Impact**: None - functionally equivalent.

### 3. Debug Attributes
Line number tables and local variable tables may differ slightly in format but should map to the same source locations.

**Impact**: Debugging experience may differ slightly.

---

## Test Categories

### Level 1: Compilation Parity

#### 1.1 Class File Generation
- [ ] All expected top-level classes are generated
- [ ] All nested classes are generated with correct names (`Outer$Inner`)
- [ ] All anonymous classes are generated with correct numbering (`Outer$1`, `Outer$2`)
- [ ] All local classes are generated with correct names

**Test Command**:
```bash
# Generate class lists
find genesis-build -name "*.class" | sed 's|genesis-build/||' | sort > genesis-classes.txt
find javac-build -name "*.class" | sed 's|javac-build/||' | sort > javac-classes.txt

# Compare (excluding known switch map classes)
diff genesis-classes.txt javac-classes.txt | grep -v '\$[0-9]*\.class'
```

#### 1.2 Class File Structure
For each class file, verify:
- [ ] Same class name and package
- [ ] Same superclass
- [ ] Same implemented interfaces
- [ ] Same access modifiers (public, final, abstract, etc.)
- [ ] Same inner class attributes

**Test Tool**: `javap -v` comparison

### Level 2: Member Parity

#### 2.1 Field Declarations
- [ ] Same field names
- [ ] Same field types
- [ ] Same field modifiers (public, private, static, final, etc.)
- [ ] Same constant values for `static final` fields

**Test Command**:
```bash
javap -p genesis-build/com/example/MyClass.class | grep -E "^\s+\w" > genesis-fields.txt
javap -p javac-build/com/example/MyClass.class | grep -E "^\s+\w" > javac-fields.txt
diff genesis-fields.txt javac-fields.txt
```

#### 2.2 Method Declarations
- [ ] Same method names
- [ ] Same parameter types
- [ ] Same return types
- [ ] Same method modifiers
- [ ] Same throws clauses
- [ ] Same generic signatures

**Test Command**:
```bash
javap -s genesis-build/com/example/MyClass.class > genesis-sigs.txt
javap -s javac-build/com/example/MyClass.class > javac-sigs.txt
diff genesis-sigs.txt javac-sigs.txt
```

### Level 3: Runtime Parity

#### 3.1 Basic Execution
Classes compiled by Genesis should execute identically to those compiled by javac.

**Test Approach**:
```bash
# Compile test harness with javac
javac TestRunner.java -d runner-build

# Run against Genesis-compiled classes
java -cp runner-build:genesis-build TestRunner

# Run against javac-compiled classes  
java -cp runner-build:javac-build TestRunner

# Compare outputs
```

#### 3.2 Reflection Parity
Reflection APIs should return identical results for both compilers.

**Test Cases**:
- [ ] `Class.getDeclaredMethods()` returns same methods
- [ ] `Class.getDeclaredFields()` returns same fields
- [ ] `Class.getDeclaredConstructors()` returns same constructors
- [ ] `Class.getAnnotations()` returns same annotations
- [ ] `Method.getParameterTypes()` returns same types
- [ ] `Method.getGenericParameterTypes()` returns same generic types

#### 3.3 Serialization Parity
Serialized objects should be interchangeable.

**Test Cases**:
- [ ] Object serialized with Genesis classes can be deserialized with javac classes
- [ ] Object serialized with javac classes can be deserialized with Genesis classes
- [ ] `serialVersionUID` matches (if not explicitly declared)

### Level 4: Interoperability

#### 4.1 Mixed Compilation
Genesis-compiled classes should work seamlessly with javac-compiled classes.

**Test Cases**:
- [ ] Genesis class can extend javac-compiled class
- [ ] Genesis class can implement javac-compiled interface
- [ ] javac class can extend Genesis-compiled class
- [ ] javac class can call methods on Genesis-compiled objects
- [ ] Generic type parameters are preserved across compiler boundaries

#### 4.2 Library Compatibility
Genesis-compiled code should work with standard libraries and frameworks.

**Test Cases**:
- [ ] Works with JUnit test runner
- [ ] Works with logging frameworks (java.util.logging, SLF4J)
- [ ] Works with serialization frameworks (Jackson, Gson)
- [ ] Works with dependency injection (if applicable)

### Level 5: Bytecode Analysis

#### 5.1 Stack Map Frames
- [ ] Valid stack map frames for all methods
- [ ] Passes JVM verification at all class file versions

**Test Command**:
```bash
java -Xverify:all -cp genesis-build com.example.Main
```

#### 5.2 Exception Tables
- [ ] Correct try-catch-finally handling
- [ ] Exception ranges match expected source constructs

#### 5.3 Local Variable Allocation
- [ ] Correct local variable indices
- [ ] No variable slot conflicts
- [ ] Proper handling of wide types (long, double)

---

## Automated Test Suite

### Test Script: `test-parity.sh`

```bash
#!/bin/bash
set -e

GUMDROP_SRC="/Users/cburdess@mimecast.com/cpkb/gumdrop/src"
GUMDROP_LIB="/Users/cburdess@mimecast.com/cpkb/gumdrop/lib"
JARS=$(ls $GUMDROP_LIB/*.jar | tr '\n' ':')

echo "=== Compiling with Genesis ==="
rm -rf genesis-build && mkdir genesis-build
./genesis @gumdrop-files-no-module.txt -d genesis-build -j -cp "$JARS"
GENESIS_COUNT=$(find genesis-build -name "*.class" | wc -l)

echo "=== Compiling with javac ==="
rm -rf javac-build && mkdir javac-build  
javac @gumdrop-files-no-module.txt -d javac-build -cp "$JARS"
JAVAC_COUNT=$(find javac-build -name "*.class" | wc -l)

echo "=== Results ==="
echo "Genesis: $GENESIS_COUNT class files"
echo "javac:   $JAVAC_COUNT class files"

echo "=== Comparing class lists ==="
find genesis-build -name "*.class" | sed 's|genesis-build/||' | sort > /tmp/genesis.txt
find javac-build -name "*.class" | sed 's|javac-build/||' | sort > /tmp/javac.txt

# Count differences excluding switch map classes
MISSING=$(diff /tmp/genesis.txt /tmp/javac.txt | grep "^>" | grep -v '\$[0-9]*\.class' | wc -l)
EXTRA=$(diff /tmp/genesis.txt /tmp/javac.txt | grep "^<" | wc -l)

echo "Missing classes (excl. switch maps): $MISSING"
echo "Extra classes: $EXTRA"

if [ "$MISSING" -gt 0 ] || [ "$EXTRA" -gt 0 ]; then
    echo "=== Unexpected differences ==="
    diff /tmp/genesis.txt /tmp/javac.txt | grep -v '\$[0-9]*\.class' || true
fi

echo "=== Comparing method signatures for sample classes ==="
for class in "org/bluezoo/gumdrop/Connection" "org/bluezoo/gumdrop/http/HTTPConnection"; do
    echo "Checking $class..."
    javap -p genesis-build/$class.class 2>/dev/null | grep -E "^\s+\w" | sort > /tmp/g-methods.txt
    javap -p javac-build/$class.class 2>/dev/null | grep -E "^\s+\w" | sort > /tmp/j-methods.txt
    if ! diff -q /tmp/g-methods.txt /tmp/j-methods.txt > /dev/null 2>&1; then
        echo "  MISMATCH in $class"
        diff /tmp/g-methods.txt /tmp/j-methods.txt || true
    else
        echo "  OK"
    fi
done

echo "=== Verification with JVM ==="
# Try loading a few classes to verify they pass JVM verification
java -Xverify:all -cp "genesis-build:$JARS" -version 2>&1 || echo "JVM verification check"

echo "=== Done ==="
```

---

## Regression Test Cases

### Specific Constructs to Test

| Construct | Test File | Status |
|-----------|-----------|--------|
| Enhanced for with `final` | `JSPPrecompiler.java` | Fixed |
| Anonymous inner classes | `JSPPrecompiler.java` | Working |
| Named nested classes | `JSPPrecompiler.java` | Fixed |
| Local classes in methods | Various | Working |
| Enum switch statements | Various | Different bytecode |
| **Throws clauses** | `Connection.java`, `Context.java` | **Missing** |
| Lambda expressions | Various | To verify |
| Method references | Various | To verify |
| Generic type bounds | Various | To verify |
| Multi-dimensional arrays | `RESPEncoder.java` | Fixed |
| Varargs methods | Various | To verify |
| Default interface methods | Various | To verify |
| Records (Java 16+) | Test files | To verify |
| Sealed classes (Java 17+) | Test files | To verify |
| Pattern matching (Java 21+) | Test files | To verify |

---

## Future Work

### Switch Map Class Generation
To achieve byte-identical output with javac, Genesis would need to:
1. Detect enum switch statements
2. Generate synthetic `$1`, `$2`, etc. inner classes
3. Create `$SwitchMap$<EnumType>` static int arrays
4. Emit `tableswitch`/`lookupswitch` using the map array

**Priority**: Low (functionally equivalent currently)

### Constant Pool Ordering
To achieve identical constant pool ordering:
1. Track order of constant pool entries as they appear in source
2. Match javac's deduplication strategy

**Priority**: Low (no functional impact)

---

## Verification Checklist

Before declaring full parity:

- [ ] All non-switch-map classes generated
- [ ] All classes pass JVM verification
- [ ] Method signatures match exactly
- [ ] Field declarations match exactly  
- [ ] Annotations preserved correctly
- [ ] Generic signatures match
- [ ] Classes interoperate with javac-compiled code
- [ ] Reflection returns identical results
- [ ] Serialization interoperates
- [ ] All test suites pass with Genesis-compiled classes

